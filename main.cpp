/**
 * @file delta-k.cpp
 * @brief A polyalphabetic substitution cipher program using Base-3 arithmetic.
 *
 * This program implements a custom encryption algorithm ("Delta-K") that converts
 * text into a trinary format (using glyphs ▲, ▼, ◆). It supports two modes:
 * 1. Standard Mode: A monoalphabetic substitution where each letter maps to a fixed triplet.
 * 2. Delta Mode: A polyalphabetic substitution (Vigenère-style) where the ciphertext
 * is generated by performing modulo-3 addition between the plaintext trits and
 * the key trits.
 *
 * @author agender-nerd (Kazy)
 * @date 2025
 *
 * @note Documentation comments generated by Gemini AI.
 */

#include <iostream>
#include <string>
#include <cctype>

/**
 * @brief The length of the standard alphabet (A-Z).
 */
const int ALPHABET_LENGTH = 26;

/**
 * @brief The base of the numbering system used for encryption (Base-3).
 */
const int BASE = 3;

/**
 * @brief The glyphs representing the three digits of the trinary system.
 * Index 0 = ▲, Index 1 = ▼, Index 2 = ◆.
 */
const std::string GLYPHS[BASE] = {"▲", "▼", "◆"};

/**
 * @brief A 2D array mapping each letter (0-25) to its unique 3-trit representation.
 * Each row corresponds to a letter (Row 0 = 'A'), and the columns contain
 * the three trits (0, 1, or 2) that represent that letter.
 */
const int TRIT_ALPHABET[ALPHABET_LENGTH][BASE] = {
    {0, 0, 1}, {0, 0, 2}, {0, 1, 0}, {0, 1, 1}, {0, 1, 2}, 
    {0, 2, 0}, {0, 2, 1}, {0, 2, 2}, {1, 0, 0}, {1, 0, 1}, 
    {1, 0, 2}, {1, 1, 0}, {1, 1, 1}, {1, 1, 2}, {1, 2, 0}, 
    {1, 2, 1}, {1, 2, 2}, {2, 0, 0}, {2, 0, 1}, {2, 0, 2},
    {2, 1, 0}, {2, 1, 1}, {2, 1, 2}, {2, 2, 0}, {2, 2, 1}, 
    {2, 2, 2}
};

// Main encoder function
std::string encrypt(const std::string& plaintext);
std::string encrypt(const std::string& plaintext, const std::string& key);

// Helper function(s)
int abcPosition(char abc);
bool keyValidation(const std::string& key);

/**
 * @brief The main entry point for the Delta-K cipher program.
 * * Handles user interaction, input collection for plaintext and key,
 * validation of the key, and routing to the appropriate encryption function.
 * * @return int Execution status code.
 */
int main() {
    std::string plaintext;
    std::string ciphertext;
    std::string key;

    std::cout << "Please enter plaintext to encode:" << std::endl;
    std::getline(std::cin, plaintext);
    
    do {
        std::cout << "Enter key (0 for normal cipher):" << std::endl;
        std::cin >> key;
        
        if (key == "0") {
            ciphertext = encrypt(plaintext);
        } else if (!keyValidation(key)) {
            std::cout << "Key invalid. Try again." << std::endl;
        } else {
            ciphertext = encrypt(plaintext, key);
        }
    } while (!(keyValidation(key) || key == "0"));

    std::cout << "Encoded ciphertext:" << std::endl;
    std::cout << ciphertext << std::endl;
    return 0;
}

/**
 * @brief Performs standard monoalphabetic encryption (Unkeyed).
 * * Converts each alphabetic character in the plaintext directly to its
 * corresponding sequence of 3 glyphs from the TRIT_ALPHABET.
 * * @param plaintext The source string to encrypt.
 * @return std::string The resulting string of glyphs.
 * @note Non-alphabetic characters are preserved as-is. Spaces (' ') are converted to forward slashes.
 */
std::string encrypt(const std::string& plaintext) {
    std::string ciphertext = "";

    for (size_t i = 0; i < plaintext.length(); i++) {
        char currentChar = plaintext[i];

        if (std::isalpha(currentChar)) {
            int abcValue = abcPosition(currentChar);
            for (int j = 0; j < BASE; j++) {
                ciphertext += GLYPHS[TRIT_ALPHABET[abcValue][j]]; // add the 3 corresponding glyphs to the ciphertext
            }
        } else if (currentChar == ' ') {
            ciphertext += '/';
        } else {
            ciphertext += currentChar;
        }
    }

    return ciphertext;
}

/**
 * @brief Performs polyalphabetic encryption using Base-3 modulo arithmetic (Keyed).
 * * This function implements the core "Delta-K" logic. For each letter of the plaintext:
 * 1. It identifies the corresponding letter in the key (cycling through the key if necessary).
 * 2. It looks up the trits for both the plaintext letter and the key letter.
 * 3. It adds the trits together modulo 3 ((plain + key) % 3).
 * 4. The resulting values determine the final glyphs.
 * * @param plaintext The source string to encrypt.
 * @param key The keyword used to scramble the encryption.
 * @return std::string The resulting string of glyphs.
 * @note This method effectively creates a unique symbol set for every letter, making
 * frequency analysis significantly more difficult.
 */
std::string encrypt(const std::string& plaintext, const std::string& key) {
    std::string ciphertext = "";
    size_t keyIndex = 0;

    for (size_t i = 0; i < plaintext.length(); i++) {
        char currentChar = plaintext[i];

        if (std::isalpha(currentChar)) {
            char currentKeyChar = key[keyIndex % key.length()];
            int keyAbcVal = abcPosition(currentKeyChar);

            int abcVal = abcPosition(currentChar);

            for (int j = 0; j < BASE; j++) {
                int keyedValue = TRIT_ALPHABET[abcVal][j] + TRIT_ALPHABET[keyAbcVal][j];
                keyedValue %= 3;
                ciphertext += GLYPHS[keyedValue]; 
            }
            
            keyIndex++; 
        } else if (currentChar == ' ') {
            ciphertext += '/';
        } else {
            ciphertext += currentChar;
        }
    }

    return ciphertext;
}

/**
 * @brief Converts a character to its 0-indexed position in the alphabet.
 * * @param abc The character to convert.
 * @return int The position (0-25) relative to 'A'.
 */
int abcPosition(char abc) {
    char abcUpper = std::toupper(abc);
    int asciiVal = abcUpper - 'A';
    return asciiVal;
}

/**
 * @brief Validates that a key is non-empty and contains only alphabetic characters.
 * * @param key The input string to validate.
 * @return true If the key is valid (not empty, only letters).
 * @return false If the key is empty or contains numbers/symbols.
 */
bool keyValidation(const std::string& key) {
    if (key.empty()) return false;

    // Iterates through every letter; if  a number or symbol is found, key is invalid
    for (size_t i = 0; i < key.length(); i++) {
        if (!std::isalpha(key[i])) {
            return false;
        }
    }

    return true;
}